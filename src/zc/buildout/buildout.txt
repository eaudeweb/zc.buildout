Defining Buildouts
==================

This document describes how to define buildouts using buildout
configuation files and recipes.  There are two ways to set up the
buildout software and create a buildout:

1. Install the zc.buildout egg with easy_install and use the buildout
   script installed in a Python scripts area.

2. Use the buildout bootstrap script to install both the setuptools
   and zc.buildout eggs into your buildout.  This allows you to use
   the buildout software without modifying a Python install.
   The buildout script is installed into your buildout local scripts
   area.

We have a sample buildout that has already been created for us.  It
has the absolute minimum information.  We have bin, eggs and parts
directories, a configuration file, and an .installed,cfg that contains
informatiion about previously-installed parts:
    
    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  eggs
    d  parts

The bin directory contains scripts.  In the examples shown here, we've
used a hybrid approach for creating the to ease automated setup.  We
have a buildout script in our buildout script directory, but the eggs
actually live elsewhere.

    >>> ls(sample_buildout, 'bin')
    -  buildout

    >>> ls(sample_buildout, 'eggs')

Buildouts are defined using configuration files.  These are in the
format defined by the Python ConfigParser module, with an extension
that we'll describe later.  When a buildout is run, it looks for the
file buildout.cfg in the directory where the buidout is run.

The parts directory is initially empty:

    >>> ls(sample_buildout, 'parts')

The parts directory provides an area where recipies can install
part data.  For example, if we built a custom Python, we would
install it in the part directory.  Part data is stored in a
subdirectory of the parts directory with the same name as the part.

The file .installed.cfg contains information about previously installed
parts. Because this is a new buildout, this file isn't very
interesting:

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    parts =

The minimal configuration file has a buildout section that defines no
parts:

    >>> cat(sample_buildout, 'buildout.cfg')
    [buildout]
    parts =

A part is simply something to be created by a buildout.  It can be
almost anything, such as a Python package, a program, a directory, or
a confguration file.  

A part is created by a recipe.  Recipes are always installed as Python
eggs. They can be downloaded from an package server, such as the
Python Package Index, or they can be developed as part of a project.
Let's create a recipe as part of the sample project.  We'll create a
recipe for creating directories.  

First, we'll create a recipes directory for
our local recipes:

    >>> mkdir(sample_buildout, 'recipes')

and then we'll create a source file for our mkdir recipe:

    >>> write(sample_buildout, 'recipes', 'mkdir.py', 
    ... """
    ... import os
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.buildout = buildout
    ...         self.name = name
    ...         self.options = options
    ...
    ...     def install(self):
    ...         path = self.buildout.buildout_path(self.options['path'])
    ...         if not os.path.isdir(path):
    ...             print 'Creating directory', os.path.basename(path)
    ...             os.mkdir(path)
    ...         return path
    ... """)

The recipe defines a constructor that takes a buildout object, a part
name, and an options dictionary. It saves them in instance attributes.

The install method is responsible for creating the part.  In this
case, we need the path of the directory to create.  We'll use a
buildout option from our options dictionary.  If the path is relative,
we'll interpret it relative to the buildout directory.  The buildout
buildout_path method gives us a path relative to the buildout.  It
uses os.path.join, so if we pass it an absolute path, we'll get the
absolute path back. (If no arguments are passed to base_path, then the
buildout directory is returned.)

We made the method chatty so that we can observe what it's doing.

We return the path that we installed.  If the part is unistalled or
reinstalled, then the path returned will be removed by the buildout
machinery.  A recipe install method is expected to return None, a
string, or an iterable of strings containing paths to be removed if a
part is uninstalled.

We need to provide packaging information so that our recipe can be
installed as an egg.  We need to define a setup script for this:

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... 
    ... setup(
    ...     name = "recipes",
    ...     entry_points = {'zc.buildout': ['mkdir = mkdir:Mkdir']},
    ...     )
    ... """)

Here we've defined a package containing just our module.  We've also
defined an entry point.  Entry points provide a way for an egg to
define the services it provides.  Here we've said that we define a
zc.buildout entry point named default.  Recipe classes must be exposed
as entry points in the zc.buildout group.  we give entry points names
within the group.  The name "default" is somewhat special because it
allows a recipe to be referenced using a package name without naming
an entry point.

We also need a README.txt for our recipes to avoid a warning:

    >>> write(sample_buildout, 'recipes', 'README.txt', " ")

Now let's update our buildout.cfg:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data_dir
    ...
    ... [data_dir]
    ... recipe = recipes:mkdir
    ... path = mystuff
    ... """)

Let's go through the changes one by one::

    develop = recipes

This tells the buildout to install a development egg for our recipes.
Any number of paths can be listed.  The paths can be relative or
absolute.  If relative, they are treated as relative to the buidlout
directory.  They can be directory or file paths.  If a file path is
given, it should point to a Python setup script.  If a directory path
is given, it should point to a directory containing a setup.py.
Development eggs are installed before building any parts, as they may
provide locally-defined recipes needed by the parts.

::

    parts = data_dir

Here we've named a part to be "built".  We can use any name we want
except that different part names must be unique and recipes will often
use the part name to decide what to do.

::

    [data_dir]
    recipe = recipes:mkdir
    path = mystuff    

Generally, when we name a part, we also create a section of the same
name that contains part data.  In this section, we'll usually define
the recipe to be used to install the part.  In this case, we also
specify the path to be created.

Let's run the buildout.  We do so by running the build script in the
buildout:

    >>> import os
    >>> os.chdir(sample_buildout)
    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    Creating directory mystuff

We see that the recipe created the directory, as expected:

    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  eggs
    d  mystuff
    d  parts
    d  recipes

In addition, .installed.cfg has been updated to reflect the part we
installed:

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    parts = data_dir
    <BLANKLINE>
    [data_dir]
    __buildout_installed__ = mystuff
    __buildout_signature__ = recipes-O3ypTgKOkHMqMwKvMfvHnA==
    path = mystuff
    recipe = recipes:mkdir

Note that the directory we installed is included in .installed.cfg.

If we change the name of the directory in the configuration file,
we'll see that the directory gets removed and recreated:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data_dir
    ...
    ... [data_dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    Creating directory mydata

    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  eggs
    d  mydata
    d  parts
    d  recipes

Variable substitutions
----------------------

Buildout configuration files support two kinds of substitutions,
standard ConfigParser substitutions, and string-template
substitutions.  To illustrate this, we'll create an debug recipe to
allow us to see interactions with the buildout:

    >>> write(sample_buildout, 'recipes', 'debug.py', 
    ... """
    ... class Debug:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.buildout = buildout
    ...         self.name = name
    ...         self.options = options
    ...
    ...     def install(self):
    ...         items = self.options.items()
    ...         items.sort()
    ...         for option, value in items:
    ...             print option, value
    ... """)

In this example, we've used a simple base class that provides a
boilerplate constructor.  This recipe doesn't actually create
anything. The install method doesn't return anything, because it
didn't create any files or directories.

We also have to update our setup script:

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... entry_points = (
    ... '''
    ... [zc.buildout]
    ... mkdir = mkdir:Mkdir
    ... debug = debug:Debug
    ... ''')
    ... setup(name="recipes", entry_points=entry_points)
    ... """)

We've rearranged the script a bit to make the entry points easier to
edit.

Let's update our configuration to provide variable substitution
examples:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data_dir debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... file1 = ${data_dir:path}/file
    ... file2 = %(file1)s.out
    ... file3 = %(base)s/file3
    ...
    ... [data_dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ...
    ... [DEFAULT]
    ... base = var
    ... """)

In this example, we've used ConfigParser substitutions for file2 and
file3.  This type of substitution uses Python string format syntax.
Valid names are option in the same section and options defined in the
DEFAULT section.  We used a string-template substitution for file1.
This type of substituion uses the string.Template syntax.  Names
substited are qualified option names, consisting of a section name and
option name joined by a colon.

Now, if we run the buildout, we'll see the options with the values
substituted. 

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    Creating directory mydata
    base var
    file1 mydata/file
    file2 mydata/file.out
    file3 var/file3
    recipe recipes:debug

It might seem surprising that mydata was created again.  This is
because we changed our recipes package by adding the debug module.
The buildout system didn't know if this module could effect the mkdir
recipe, so it assumed it could and reinstalled mydata.  If we rerun
the buildout:

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    base var
    file1 mydata/file
    file2 mydata/file.out
    file3 var/file3
    recipe recipes:debug

We can see that mydata was not recreated.

Multiple configuration files
----------------------------

You can use multiple configuration files.  From your main
configuration file, you can include other configuration files in 2
ways:

- Your configuration file can "extend" another configuration file.
  Option are read from the other configuration file if they aren't
  already defined by your configuration file.

- Your configuration file can be "extended-by" another configuration
  file, In this case, the options in the other configuration file
  override options in your configuration file. 

The configuration files your file extends or is extended by can extend
or be extended by other configuration files.  The same file may be
used more than once although, of course, cycles aren't allowed.

To see how this works, we use an example:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op = buldout
    ... """)

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... op = base
    ... """)

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    op buldout
    recipe recipes:debug

The example is pretty trivial, but the pattern it illustrates is
pretty common.  In a more practical example, the base buildout might
represent a product and the extending buildout might be a
customization. 

Here is a more eleborate example. 

    >>> import tempfile
    >>> extensions = tempfile.mkdtemp()

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... extends = b1.cfg b2.cfg
    ... extended-by = e1.cfg %(e2)s
    ...
    ... [debug]
    ... op = %%(name)s
    ...
    ... [DEFAULT]
    ... name = buildout
    ... """ % dict(e2=os.path.join(extensions, 'e2.cfg')))


    >>> write(sample_buildout, 'b1.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op1 = %(name)s 1
    ... op2 = %(name)s 2
    ... op3 = %(name)s 3
    ...
    ... [DEFAULT]
    ... name = b1
    ... """)

    >>> write(sample_buildout, 'b2.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op3 = %(name)s 3
    ... op4 = %(name)s 4
    ... op5 = %(name)s 5
    ...
    ... [DEFAULT]
    ... name = b2
    ... """)

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... name = base
    ... """)

    >>> write(sample_buildout, 'e1.cfg',
    ... """
    ... [debug]
    ... op1 = %(name)s 1
    ...
    ... [DEFAULT]
    ... name = e1
    ... """)

    >>> write(extensions, 'e2.cfg',
    ... """
    ... [buildout]
    ... extends = eb.cfg
    ... extended-by = ee.cfg
    ... """)

    >>> write(extensions, 'eb.cfg',
    ... """
    ... [debug]
    ... op5 = %(name)s 5
    ...
    ... [DEFAULT]
    ... name = eb
    ... """)

    >>> write(extensions, 'ee.cfg',
    ... """
    ... [debug]
    ... op6 = %(name)s 6
    ...
    ... [DEFAULT]
    ... name = ee
    ... """)

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    name ee
    op buildout
    op1 e1 1
    op2 b1 2
    op3 b2 3
    op4 b2 4
    op5 eb 5
    op6 ee 6
    recipe recipes:debug

There are several things to note about this example:

- We can name multiple files in an extends or extended-by option.

- We can reference files recursively.

- DEFAULT sections only directly affect the configuration file they're
  used in, but they can have secondary effects.  For example, the name
  option showed up in the debug section because it was defined in the
  debug sections in several of the input files by virtue of being in
  their DEFAULT sections.

- Relative file names are determined relative to the directory
  containing the referencing configuration file.  The files eb.cfg and
  ee.cfg were found in the extensions directory because they were
  referenced from a file in that directory.

User defaults
-------------

If the file $HOME/.buildout/defaults.cfg, exists, it is read before
reading the configuration file.  ($HOME is the value of the HOME
enviornment variable. The '/' is replaced by the operating system file
delimiter.)

    >>> home = tempfile.mkdtemp()
    >>> mkdir(home, '.buildout')
    >>> write(home, '.buildout', 'default.cfg',
    ... """
    ... [debug]
    ... op1 = 1
    ... op7 = 7
    ... """)

    >>> os.environ['HOME'] = home
    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    name ee
    op buildout
    op1 e1 1
    op2 b1 2
    op3 b2 3
    op4 b2 4
    op5 eb 5
    op6 ee 6
    op7 7
    recipe recipes:debug

Command-line usage
------------------

A number of arguments can be given on the buildout command line.  The
command usage is::

  buildout [-c file] [options] [command [command arguments]]

The -c option can be used to specify a configuration file, rather than
buildout.cfg in the current durectory.  Options are of the form::

  section_name:option_name=value

for example, as in:

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')
    ...     + ' debug:op1=foo'),
    name ee
    op buildout
    op1 foo
    op2 b1 2
    op3 b2 3
    op4 b2 4
    op5 eb 5
    op6 ee 6
    op7 7
    recipe recipes:debug

Currently, the default and only command is 'install' and it takes a
list of parts to install. if any parts are specified, then only those
parts are installed.  To illustrate this, we'll update our
configuration and run the buildout in the usual way:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug d1 d2 d3
    ...
    ... [d1]
    ... recipe = recipes:mkdir
    ... path = d1
    ...
    ... [d2]
    ... recipe = recipes:mkdir
    ... path = d2
    ...
    ... [d3]
    ... recipe = recipes:mkdir
    ... path = d3
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    op1 1
    op7 7
    recipe recipes:debug
    Creating directory d1
    Creating directory d2
    Creating directory d3
    
    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  d1
    d  d2
    d  d3
    -  e1.cfg
    d  eggs
    d  parts
    d  recipes

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    parts = debug d1 d2 d3
    <BLANKLINE>
    [debug]
    __buildout_installed__ = 
    __buildout_signature__ = recipes-IX/o5hMSw90MtZVxRpjz0Q==
    op1 = 1
    op7 = 7
    recipe = recipes:debug
    <BLANKLINE>
    [d1]
    __buildout_installed__ = d1
    __buildout_signature__ = recipes-IX/o5hMSw90MtZVxRpjz0Q==
    path = d1
    recipe = recipes:mkdir
    <BLANKLINE>
    [d2]
    __buildout_installed__ = d2
    __buildout_signature__ = recipes-IX/o5hMSw90MtZVxRpjz0Q==
    path = d2
    recipe = recipes:mkdir
    <BLANKLINE>
    [d3]
    __buildout_installed__ = d3
    __buildout_signature__ = recipes-IX/o5hMSw90MtZVxRpjz0Q==
    path = d3
    recipe = recipes:mkdir

Now we'll update our configuration file:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug d2 d3 d4
    ...
    ... [d2]
    ... recipe = recipes:mkdir
    ... path = data2
    ...
    ... [d3]
    ... recipe = recipes:mkdir
    ... path = data3
    ...
    ... [d4]
    ... recipe = recipes:mkdir
    ... path = data4
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... x = 1
    ... """)

and run the buildout specifying just d2 and d3:

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')
    ...              + ' install d3 d4'),
    Creating directory data3
    Creating directory data4
    
    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  d1
    d  d2
    d  data3
    d  data4
    -  e1.cfg
    d  eggs
    d  parts
    d  recipes
    
Only the d2 and d3 recipes ran.  d2 was removed and data2 and data3
were created.

The .installed.cfg is only updated for the recipes that ran:

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    parts = debug d2 d3 d4 d1
    <BLANKLINE>
    [debug]
    __buildout_installed__ = 
    __buildout_signature__ = recipes-IX/o5hMSw90MtZVxRpjz0Q==
    op1 = 1
    op7 = 7
    recipe = recipes:debug
    <BLANKLINE>
    [d2]
    __buildout_installed__ = d2
    __buildout_signature__ = recipes-IX/o5hMSw90MtZVxRpjz0Q==
    path = d2
    recipe = recipes:mkdir
    <BLANKLINE>
    [d3]
    __buildout_installed__ = data3
    __buildout_signature__ = recipes-IX/o5hMSw90MtZVxRpjz0Q==
    path = data3
    recipe = recipes:mkdir
    <BLANKLINE>
    [d4]
    __buildout_installed__ = data4
    __buildout_signature__ = recipes-IX/o5hMSw90MtZVxRpjz0Q==
    path = data4
    recipe = recipes:mkdir
    <BLANKLINE>
    [d1]
    __buildout_installed__ = d1
    __buildout_signature__ = recipes-IX/o5hMSw90MtZVxRpjz0Q==
    path = d1
    recipe = recipes:mkdir

Note that the installed data for debug, d1, and d2 haven't changed,
because we didn't install those parts and that the d1 and d2
directories are still there.

Now, if we run the buildout without arguments:

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    op1 1
    op7 7
    recipe recipes:debug
    x 1
    Creating directory data2

We see the output of the debug recipe and that data2 was created.  We
also see that d1 and d2 have gone away:

    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  data2
    d  data3
    d  data4
    -  e1.cfg
    d  eggs
    d  parts
    d  recipes

Alternate directory locations
-----------------------------

The buildout normally puts the bin, eggs, and parts directories in the
directory in the directory containing the configuration file. You can
provide alternate locations, and even names for these directories.

    >>> alt = tempfile.mkdtemp()

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = 
    ... eggs-directory = %(basket)s
    ... bin-directory = %(scripts)s
    ... parts-directory = %(work)s
    ... """ % dict(
    ...    basket = os.path.join(alt, 'basket'),
    ...    scripts = os.path.join(alt, 'scripts'),
    ...    work = os.path.join(alt, 'work'),
    ... ))

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),

    >>> ls(alt)
    d  basket
    d  scripts
    d  work

    >>> ls(alt, 'basket')    
    -  recipes.egg-link

    >>> import shutil
    >>> shutil.rmtree(alt)

You can also specify an alternate buildout directory:

    >>> alt = tempfile.mkdtemp()

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... directory = %(alt)s
    ... develop = %(recipes)s
    ... parts = 
    ... """ % dict(
    ...    alt=alt,
    ...    recipes=os.path.join(sample_buildout, 'recipes'),
    ...    ))
 
    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),

    >>> ls(alt)
    -  .installed.cfg
    d  bin
    d  eggs
    d  parts

    >>> ls(alt, 'eggs')    
    -  recipes.egg-link

    >>> import shutil
    >>> shutil.rmtree(alt)

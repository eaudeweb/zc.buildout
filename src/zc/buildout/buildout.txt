Buildouts
=========

The word "buildout" refers to a description of a set of parts and the
software to create and assemble them.  It is often used informally to
refer to an installed system based on a buildout definition.  For
example, if we are creating an application named "Foo", then "the Foo
buildout" is the collection of configuration and application-specific
software that allows an instance of the application to be created.  We
may refer to such an instance of the application informally as "a Foo
buildout".  

This document describes how to define buildouts using buildout
configuation files and recipes.  There are two ways to set up the
buildout software and create a buildout instance:

1. Install the zc.buildout egg with easy_install and use the buildout
   script installed in a Python scripts area.

2. Use the buildout bootstrap script to create a buildout that
   includes both the setuptools and zc.buildout eggs.  This allows you
   to use the buildout software without modifying a Python install.
   The buildout script is installed into your buildout local scripts
   area.

Often, a software project will be managed in a software repository,
such as a subversion repository, that includes some software source
directories, buildout configuration files, and a copy of the buildout
bootstrap script,  To work on the project, one would check out the
project from the repository and run the bootstrap script which
installs setuptools and zc.buildout into the checkout as well as any
parts defined.

We have a sample buildout that has already been created for us.  It
has the absolute minimum information.  We have bin, eggs and parts
directories, a configuration file, and an .installed,cfg that contains
informatiion about previously-installed parts:
    
    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  eggs
    d  parts

The bin directory contains scripts.  In the examples shown here, we've
used a hybrid approach for creating the buildout to ease automated
setup.  We have a buildout script in our buildout script directory,
but the zc.buildout and setuptools eggs actually live elsewhere.

    >>> ls(sample_buildout, 'bin')
    -  buildout

    >>> ls(sample_buildout, 'eggs')

The parts directory is initially empty:

    >>> ls(sample_buildout, 'parts')

The parts directory provides an area where recipies can install
part data.  For example, if we built a custom Python, we would
install it in the part directory.  Part data is stored in a
subdirectory of the parts directory with the same name as the part.

Buildouts are defined using configuration files.  These are in the
format defined by the Python ConfigParser module, with extensions
that we'll describe later.  By default, when a buildout is run, it
looks for the file buildout.cfg in the directory where the buidout is
run.

The minimal configuration file has a buildout section that defines no
parts:

    >>> cat(sample_buildout, 'buildout.cfg')
    [buildout]
    parts =

The file .installed.cfg contains information about previously installed
parts. Because this is a new buildout, this file isn't very
interesting:

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    parts =

A part is simply something to be created by a buildout.  It can be
almost anything, such as a Python package, a program, a directory, or
even a confguration file.  

A part is created by a recipe.  Recipes are always installed as Python
eggs. They can be downloaded from a package server, such as the
Python Package Index, or they can be developed as part of a project.
Let's create a recipe as part of the sample project.  We'll create a
recipe for creating directories.  

First, we'll create a recipes directory for
our local recipes:

    >>> mkdir(sample_buildout, 'recipes')

and then we'll create a source file for our mkdir recipe:

    >>> write(sample_buildout, 'recipes', 'mkdir.py', 
    ... """
    ... import logging, os
    ...
    ... class Mkdir:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.buildout = buildout
    ...         self.name = name
    ...         self.options = options
    ...         options['path'] = os.path.join(
    ...                               buildout['buildout']['directory'],
    ...                               options['path'],
    ...                               )
    ...
    ...     def install(self):
    ...         path = self.options['path']
    ...         if not os.path.isdir(path):
    ...             logging.getLogger(self.name).info(
    ...                 'Creating directory %s', os.path.basename(path))
    ...             os.mkdir(path)
    ...         return path
    ... """)

The recipe defines a constructor that takes a buildout object, a part
name, and an options dictionary. It saves them in instance attributes.

If the path is relative, we'll interpret it as relative to the
buildout directory.  The buildout object passed in is a mapping from
section name to a mapping of options for that section. The buildout
directory is available as the directory option of the buildout
section.  We normalize the path and save it back into the options
directory.  

Any time we use data from another section, it is important to reflect
that data in the recipe's options when the recipe is constructed.
When a buildout is run, it compares part-configuration data stored in
the installed.cfg file and the part-configuration data loaded from the
configuration files as modified by recipe constructors to decide if
the configuration of a part has changed. If the configuration has
changed, or if the recipe has changed, then the part is uninstalled
before reinstalling it.  The buildout only looks at the part's
options, so any data used to configure the part needs to be reflected
in the part's options.  It is the job of a recipe constructor to make
sure that the options include all relevent data.

Of course, parts are also uninstalled if they are no-longer used.

The install method is responsible for creating the part.  In this
case, we need the path of the directory to create.  We'll use a
path option from our options dictionary.

The install method logs what it's doing using the Python logging call.

We return the path that we installed.  If the part is unistalled or
reinstalled, then the path returned will be removed by the buildout
machinery.  A recipe install method is expected to return None, a
string, or an iterable of strings containing paths to be removed if a
part is uninstalled.  For most recipes, this is all of the uninstall
support needed.  A recipe can provide custom uninstall support as will
be described later.

We need to provide packaging information so that our recipe can be
installed as an egg.  We need to define a setup script for this:

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... 
    ... setup(
    ...     name = "recipes",
    ...     entry_points = {'zc.buildout': ['mkdir = mkdir:Mkdir']},
    ...     )
    ... """)

This setup script is incomplete.  It doesn't describe what is to be 
included in a distribution.  This is fine if we never actually create
a distribution. If recipes are going to be used only internally in a
buildout, then we needn't include distribution information.  If we
wanted to use the same recipes in multiple buildouts, then we'd need
to include proper distribution data.  To find out more about creating
distributions, see the setuptools documentation.

Our setup script defines an entry point. Entry points provide
a way for an egg to define the services it provides.  Here we've said
that we define a zc.buildout entry point named default.  Recipe
classes must be exposed as entry points in the zc.buildout group.  we
give entry points names within the group.  The name "default" is
somewhat special because it allows a recipe to be referenced using a
package name without naming an entry point.

We also need a README.txt for our recipes to avoid an annoying warning
from distutils, on which setuptools and zc.buildout are based:

    >>> write(sample_buildout, 'recipes', 'README.txt', " ")

Now let's update our buildout.cfg:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data_dir
    ... log-level = INFO
    ...
    ... [data_dir]
    ... recipe = recipes:mkdir
    ... path = mystuff
    ... """)

Let's go through the changes one by one::

    develop = recipes

This tells the buildout to install a development egg for our recipes.
Any number of paths can be listed.  The paths can be relative or
absolute.  If relative, they are treated as relative to the buidlout
directory.  They can be directory or file paths.  If a file path is
given, it should point to a Python setup script.  If a directory path
is given, it should point to a directory containing a setup.py file.
Development eggs are installed before building any parts, as they may
provide locally-defined recipes needed by the parts.

::

    parts = data_dir

Here we've named a part to be "built".  We can use any name we want
except that different part names must be unique and recipes will often
use the part name to decide what to do.

::

    log-level = INFO

The default level is WARNING, which is fairly quite.  In this example,
we set the level to INFO so we can see more details about what the
buildout and recipes are doing.

::

    [data_dir]
    recipe = recipes:mkdir
    path = mystuff    

Generally, when we name a part, we also create a section of the same
name that contains part data.  In this section, we'll usually define
the recipe to be used to install the part.  In this case, we also
specify the path to be created.

Let's run the buildout.  We do so by running the build script in the
buildout:

    >>> import os
    >>> os.chdir(sample_buildout)
    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    buildout: Running /tmp/sample-buildout/recipes/setup.py -q develop ...
    buildout: Installing data_dir
    data_dir: Creating directory mystuff

We see that the recipe created the directory, as expected:

    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  eggs
    d  mystuff
    d  parts
    d  recipes

In addition, .installed.cfg has been updated to reflect the part we
installed:

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    parts = data_dir
    <BLANKLINE>
    [data_dir]
    __buildout_installed__ = /tmp/sample-buildout/mystuff
    __buildout_signature__ = recipes-c7vHV6ekIDUPy/7fjAaYjg==
    path = /tmp/sample-buildout/mystuff
    recipe = recipes:mkdir

Note that the directory we installed is included in .installed.cfg.
In addition, the path option includes the actual destination
directory. 

If we change the name of the directory in the configuration file,
we'll see that the directory gets removed and recreated:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data_dir
    ... log-level = INFO
    ...
    ... [data_dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ... """)

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    buildout: Running /tmp/sample-buildout/recipes/setup.py -q develop ...
    buildout: Uninstalling data_dir
    buildout: Installing data_dir
    data_dir: Creating directory mydata

    >>> ls(sample_buildout)
    -  .installed.cfg
    d  bin
    -  buildout.cfg
    d  eggs
    d  mydata
    d  parts
    d  recipes

Variable substitutions
----------------------

Buildout configuration files support two kinds of substitutions,
standard ConfigParser substitutions, and string-template
substitutions.  To illustrate this, we'll create an debug recipe to
allow us to see interactions with the buildout:

    >>> write(sample_buildout, 'recipes', 'debug.py', 
    ... """
    ... class Debug:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.buildout = buildout
    ...         self.name = name
    ...         self.options = options
    ...
    ...     def install(self):
    ...         items = self.options.items()
    ...         items.sort()
    ...         for option, value in items:
    ...             print option, value
    ... """)

In this example, we've used a simple base class that provides a
boilerplate constructor.  This recipe doesn't actually create
anything. The install method doesn't return anything, because it
didn't create any files or directories.

We also have to update our setup script:

    >>> write(sample_buildout, 'recipes', 'setup.py',
    ... """
    ... from setuptools import setup
    ... entry_points = (
    ... '''
    ... [zc.buildout]
    ... mkdir = mkdir:Mkdir
    ... debug = debug:Debug
    ... ''')
    ... setup(name="recipes", entry_points=entry_points)
    ... """)

We've rearranged the script a bit to make the entry points easier to
edit.  In particular, entry points are now defined as a configuration
string, rather than a dictionary.

Let's update our configuration to provide variable substitution
examples:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = data_dir debug
    ... log-level = INFO
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... file1 = ${data_dir:path}/file
    ... file2 = %(file1)s.out
    ... file3 = %(base)s/file3
    ...
    ... [data_dir]
    ... recipe = recipes:mkdir
    ... path = mydata
    ...
    ... [DEFAULT]
    ... base = var
    ... """)

In this example, we've used ConfigParser substitutions for file2 and
file3.  This type of substitution uses Python string format syntax.
Valid names are options in the same section and options defined in the
DEFAULT section.  

We used a string-template substitution for file1.  This type of
substituion uses the string.Template syntax.  Names substited are
qualified option names, consisting of a section name and option name
joined by a colon.

Now, if we run the buildout, we'll see the options with the values
substituted. 

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    buildout: Running /tmp/sample-buildout/recipes/setup.py -q develop ...
    buildout: Uninstalling data_dir
    buildout: Installing data_dir
    data_dir: Creating directory mydata
    buildout: Installing debug
    base var
    file1 mydata/file
    file2 mydata/file.out
    file3 var/file3
    recipe recipes:debug

It might seem surprising that mydata was created again.  This is
because we changed our recipes package by adding the debug module.
The buildout system didn't know if this module could effect the mkdir
recipe, so it assumed it could and reinstalled mydata.  If we rerun
the buildout:

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    buildout: Running /tmp/sample-buildout/recipes/setup.py -q develop ...
    buildout: Installing data_dir
    buildout: Installing debug
    base var
    file1 mydata/file
    file2 mydata/file.out
    file3 var/file3
    recipe recipes:debug

We can see that mydata was not recreated.

Note that, in this vase, we didn't specify a log level, so
we didn't get output about what the buildout was doing.

Multiple configuration files
----------------------------

You can use multiple configuration files.  From your main
configuration file, you can include other configuration files in 2
ways:

- Your configuration file can "extend" another configuration file.
  Option are read from the other configuration file if they aren't
  already defined by your configuration file.

- Your configuration file can be "extended-by" another configuration
  file, In this case, the options in the other configuration file
  override options in your configuration file. 

The configuration files your file extends or is extended by can extend
or be extended by other configuration files.  The same file may be
used more than once although, of course, cycles aren't allowed.

To see how this works, we use an example:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op = buldout
    ... """)

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... op = base
    ... """)

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    op buldout
    recipe recipes:debug

The example is pretty trivial, but the pattern it illustrates is
pretty common.  In a more practical example, the base buildout might
represent a product and the extending buildout might be a
customization. 

Here is a more elaborate example. 

    >>> import tempfile
    >>> extensions = tempfile.mkdtemp()

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... extends = b1.cfg b2.cfg
    ... extended-by = e1.cfg %(e2)s
    ...
    ... [debug]
    ... op = %%(name)s
    ...
    ... [DEFAULT]
    ... name = buildout
    ... """ % dict(e2=os.path.join(extensions, 'e2.cfg')))

    >>> write(sample_buildout, 'b1.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op1 = %(name)s 1
    ... op2 = %(name)s 2
    ... op3 = %(name)s 3
    ...
    ... [DEFAULT]
    ... name = b1
    ... """)

    >>> write(sample_buildout, 'b2.cfg',
    ... """
    ... [buildout]
    ... extends = base.cfg
    ...
    ... [debug]
    ... op3 = %(name)s 3
    ... op4 = %(name)s 4
    ... op5 = %(name)s 5
    ...
    ... [DEFAULT]
    ... name = b2
    ... """)

    >>> write(sample_buildout, 'base.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... name = base
    ... """)

    >>> write(sample_buildout, 'e1.cfg',
    ... """
    ... [debug]
    ... op1 = %(name)s 1
    ...
    ... [DEFAULT]
    ... name = e1
    ... """)

    >>> write(extensions, 'e2.cfg',
    ... """
    ... [buildout]
    ... extends = eb.cfg
    ... extended-by = ee.cfg
    ... """)

    >>> write(extensions, 'eb.cfg',
    ... """
    ... [debug]
    ... op5 = %(name)s 5
    ...
    ... [DEFAULT]
    ... name = eb
    ... """)

    >>> write(extensions, 'ee.cfg',
    ... """
    ... [debug]
    ... op6 = %(name)s 6
    ...
    ... [DEFAULT]
    ... name = ee
    ... """)

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    name ee
    op buildout
    op1 e1 1
    op2 b1 2
    op3 b2 3
    op4 b2 4
    op5 eb 5
    op6 ee 6
    recipe recipes:debug

There are several things to note about this example:

- We can name multiple files in an extends or extended-by option.

- We can reference files recursively.

- DEFAULT sections only directly affect the configuration file they're
  used in, but they can have secondary effects.  For example, the name
  option showed up in the debug section because it was defined in the
  debug sections in several of the input files by virtue of being in
  their DEFAULT sections.

- Relative file names in extended and extended-by options are
  interpreted relative to the directory containing the referencing
  configuration file.  The files eb.cfg and ee.cfg were found in the
  extensions directory because they were referenced from a file in
  that directory.

User defaults
-------------

If the file $HOME/.buildout/defaults.cfg, exists, it is read before
reading the configuration file.  ($HOME is the value of the HOME
enviornment variable. The '/' is replaced by the operating system file
delimiter.)

    >>> home = tempfile.mkdtemp()
    >>> mkdir(home, '.buildout')
    >>> write(home, '.buildout', 'default.cfg',
    ... """
    ... [debug]
    ... op1 = 1
    ... op7 = 7
    ... """)

    >>> os.environ['HOME'] = home
    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    name ee
    op buildout
    op1 e1 1
    op2 b1 2
    op3 b2 3
    op4 b2 4
    op5 eb 5
    op6 ee 6
    op7 7
    recipe recipes:debug

Command-line usage
------------------

A number of arguments can be given on the buildout command line.  The
command usage is::

  buildout [-c file] [-q] [-v] [assignments] [command [command arguments]]

The -c option can be used to specify a configuration file, rather than
buildout.cfg in the current durectory.  

The -q and -v decrement and incremement the verbosity by 10.  The
verbosity is used to adjust the logging level.  The verbosity is
subtracted from the numeric value of the log-level option specified in
the configuration file.

Assignments are of the form::

  section_name:option_name=value

Options and assignments can be given in any order.

Here's an example:

    >>> write(sample_buildout, 'other.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug
    ... installed = .other.cfg
    ...
    ... [debug]
    ... name = other
    ... recipe = recipes:debug
    ... """)

Note that we used the installed buildout option to specify an
alternate file to store information about installed parts.
    
    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')
    ...     + ' -c other.cfg debug:op1=foo -v'),
    buildout: Running /tmp/sample-buildout/recipes/setup.py -q develop ...
    buildout: Installing debug
    name other
    op1 foo
    op7 7
    recipe recipes:debug

Here we used the -c option to specify an alternate configuration file, 
and the -v option to increase the level of logging from the default,
WARNING.

Options can also be combined in the usual Unix way, as in:
    
    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')
    ...     + ' -vcother.cfg debug:op1=foo'),
    buildout: Running /tmp/sample-buildout/recipes/setup.py -q develop ...
    buildout: Installing debug
    name other
    op1 foo
    op7 7
    recipe recipes:debug

Here we combined the -v and -c options with the configuration file
name.  Note that the -c option has to be last, because it takes an
argument.

    >>> os.remove(os.path.join(sample_buildout, 'other.cfg'))
    >>> os.remove(os.path.join(sample_buildout, '.other.cfg'))

Currently, the default and only command is 'install' and it takes a
list of parts to install. if any parts are specified, then they must
be listed in the buildout parts option and only those parts are
installed.  To illustrate this, we'll update our configuration and run
the buildout in the usual way:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug d1 d2 d3
    ...
    ... [d1]
    ... recipe = recipes:mkdir
    ... path = d1
    ...
    ... [d2]
    ... recipe = recipes:mkdir
    ... path = d2
    ...
    ... [d3]
    ... recipe = recipes:mkdir
    ... path = d3
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... """)

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout') + ' -v'),
    buildout: Running /sample-buildout/recipes/setup.py -q develop ...
    buildout: Uninstalling debug
    buildout: Installing debug
    op1 1
    op7 7
    recipe recipes:debug
    buildout: Installing d1
    d1: Creating directory d1
    buildout: Installing d2
    d2: Creating directory d2
    buildout: Installing d3
    d3: Creating directory d3
    
    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  d1
    d  d2
    d  d3
    -  e1.cfg
    d  eggs
    d  parts
    d  recipes

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    parts = debug d1 d2 d3
    <BLANKLINE>
    [debug]
    __buildout_installed__ = 
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    op1 = 1
    op7 = 7
    recipe = recipes:debug
    <BLANKLINE>
    [d1]
    __buildout_installed__ = /tmp/sample-buildout/d1
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /tmp/sample-buildout/d1
    recipe = recipes:mkdir
    <BLANKLINE>
    [d2]
    __buildout_installed__ = /tmp/sample-buildout/d2
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /tmp/sample-buildout/d2
    recipe = recipes:mkdir
    <BLANKLINE>
    [d3]
    __buildout_installed__ = /tmp/sample-buildout/d3
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /tmp/sample-buildout/d3
    recipe = recipes:mkdir

Now we'll update our configuration file:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = debug d2 d3 d4
    ...
    ... [d2]
    ... recipe = recipes:mkdir
    ... path = data2
    ...
    ... [d3]
    ... recipe = recipes:mkdir
    ... path = data3
    ...
    ... [d4]
    ... recipe = recipes:mkdir
    ... path = data4
    ...
    ... [debug]
    ... recipe = recipes:debug
    ... x = 1
    ... """)

and run the buildout specifying just d2 and d3:

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout' + ' -v')
    ...              + ' install d3 d4'),
    buildout: Running /sample-buildout/recipes/setup.py -q develop ...
    buildout: Uninstalling d3
    buildout: Installing d3
    d3: Creating directory data3
    buildout: Installing d4
    d4: Creating directory data4
    
    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  d1
    d  d2
    d  data3
    d  data4
    -  e1.cfg
    d  eggs
    d  parts
    d  recipes
    
Only the d2 and d3 recipes ran.  d2 was removed and data2 and data3
were created.

The .installed.cfg is only updated for the recipes that ran:

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    parts = debug d2 d3 d4 d1
    <BLANKLINE>
    [debug]
    __buildout_installed__ = 
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    op1 = 1
    op7 = 7
    recipe = recipes:debug
    <BLANKLINE>
    [d2]
    __buildout_installed__ = /tmp/sample-buildout/d2
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /tmp/sample-buildout/d2
    recipe = recipes:mkdir
    <BLANKLINE>
    [d3]
    __buildout_installed__ = /tmp/sample-buildout/data3
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /tmp/sample-buildout/data3
    recipe = recipes:mkdir
    <BLANKLINE>
    [d4]
    __buildout_installed__ = /tmp/sample-buildout/data4
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /tmp/sample-buildout/data4
    recipe = recipes:mkdir
    <BLANKLINE>
    [d1]
    __buildout_installed__ = /tmp/sample-buildout/d1
    __buildout_signature__ = recipes-PiIFiO8ny5yNZ1S3JfT0xg==
    path = /tmp/sample-buildout/d1
    recipe = recipes:mkdir

Note that the installed data for debug, d1, and d2 haven't changed,
because we didn't install those parts and that the d1 and d2
directories are still there.

Now, if we run the buildout without the install command:

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout') + ' -v'),
    buildout: Running /sample-buildout/recipes/setup.py -q develop ...
    buildout: Uninstalling d1
    buildout: Uninstalling d2
    buildout: Uninstalling debug
    buildout: Installing debug
    op1 1
    op7 7
    recipe recipes:debug
    x 1
    buildout: Installing d2
    d2: Creating directory data2
    buildout: Installing d3
    buildout: Installing d4

We see the output of the debug recipe and that data2 was created.  We
also see that d1 and d2 have gone away:

    >>> ls(sample_buildout)
    -  .installed.cfg
    -  b1.cfg
    -  b2.cfg
    -  base.cfg
    d  bin
    -  buildout.cfg
    d  data2
    d  data3
    d  data4
    -  e1.cfg
    d  eggs
    d  parts
    d  recipes

Alternate directory and file locations
--------------------------------------

The buildout normally puts the bin, eggs, and parts directories in the
directory in the directory containing the configuration file. You can
provide alternate locations, and even names for these directories.

    >>> alt = tempfile.mkdtemp('sample-alt')

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts = 
    ... eggs-directory = %(basket)s
    ... bin-directory = %(scripts)s
    ... parts-directory = %(work)s
    ... """ % dict(
    ...    basket = os.path.join(alt, 'basket'),
    ...    scripts = os.path.join(alt, 'scripts'),
    ...    work = os.path.join(alt, 'work'),
    ... ))

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout') + ' -v'),
    buildout: Creating directory /tmp/sample-alt/scripts
    buildout: Creating directory /tmp/sample-alt/work
    buildout: Creating directory /tmp/sample-alt/basket
    buildout: Running /tmp/sample-buildout/recipes/setup.py -q develop ...
    buildout: Uninstalling d4
    buildout: Uninstalling d3
    buildout: Uninstalling d2
    buildout: Uninstalling debug

    >>> ls(alt)
    d  basket
    d  scripts
    d  work

    >>> ls(alt, 'basket')    
    -  recipes.egg-link

    >>> import shutil
    >>> shutil.rmtree(alt)

You can also specify an alternate buildout directory:

    >>> alt = tempfile.mkdtemp('sample-alt')

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... directory = %(alt)s
    ... develop = %(recipes)s
    ... parts = 
    ... """ % dict(
    ...    alt=alt,
    ...    recipes=os.path.join(sample_buildout, 'recipes'),
    ...    ))
 
    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout') + ' -v'),
    buildout: Creating directory /tmp/sample-alt/bin
    buildout: Creating directory /tmp/sample-alt/parts
    buildout: Creating directory /tmp/sample-alt/eggs
    buildout: Running /tmp/sample-buildout/recipes/setup.py -q develop ...

    >>> ls(alt)
    -  .installed.cfg
    d  bin
    d  eggs
    d  parts

    >>> ls(alt, 'eggs')    
    -  recipes.egg-link

    >>> import shutil
    >>> shutil.rmtree(alt)

Logging control
---------------

Three buildout options are used to control logging:

log-level 
   specifies the log level

verbosity 
   adjusts the log level

log-format
   allows an alternate logging for mat to be specified

We've already seen the log level and verbosity.  Let's look at an example
of changing the format:

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = recipes
    ... parts =
    ... log-level = 25
    ... verbosity = 5
    ... log-format = %%(levelname)s %%(message)s
    ... """)
 
Here, we've changed the format to include the log-level name, rather
than the logger name.  

We've also illustrated, with a contrived example, that the log level
can be a numeric value and that the verbosity can be specified in the
configuration file.  Because the verbosoty is subtracted from the log
level, we get a final log level of 20, which is the INFO level.

    >>> print system(os.path.join(sample_buildout, 'bin', 'buildout')),
    INFO Running /tmp/sample-buildout/recipes/setup.py -q develop ...

Egg Recipe API for other Recipes
================================

It is common for recipes to accept a collection of egg specifications
and generate scripts based on the resulting working sets.  The egg
recipe provides an API that other recipes can use.

A recipe can reuse the egg recipe, supporting the eggs, find-links,
index, and pythonoptions.  This is done by creating an egg
recipe instance in a recipes's contructor.  In the recipe's install
script, the egg-recipe instance's working_set method to collect the
requested eggs and working set. 

To illustrate, we create a sample recipe that is a very thin layer
around the egg recipe:

    >>> mkdir(sample_buildout, 'sample')
    >>> write(sample_buildout, 'sample', 'sample.py', 
    ... """
    ... import logging, os
    ... import zc.recipe.egg
    ...
    ... class Sample:
    ...
    ...     def __init__(self, buildout, name, options):
    ...         self.egg = zc.recipe.egg.Egg(buildout, name, options)
    ...         self.name = name
    ...         self.options = options
    ...
    ...     def install(self):
    ...         extras = self.options['extras'].split()
    ...         requirements, ws = self.egg.working_set(extras)
    ...         print 'Part:', self.name
    ...         print 'Egg requirements:'
    ...         for r in requirements:
    ...             print r
    ...         print 'Working set:'
    ...         for d in ws:
    ...             print d
    ... """)

Here we instantiated the egg recipe in the constructor, saving it in
an attribute.  This also initialized the options dictionary.

In our install method, we called the working_set method on the
instance we saved.  The working_set method takes an optional sequence
of extra requirements to be included in the working set.

    >>> write(sample_buildout, 'sample', 'setup.py',
    ... """
    ... from setuptools import setup
    ... 
    ... setup(
    ...     name = "sample",
    ...     entry_points = {'zc.buildout': ['default = sample:Sample']},
    ...     )
    ... """)


    >>> write(sample_buildout, 'sample', 'README.txt', " ")

    >>> write(sample_buildout, 'buildout.cfg',
    ... """
    ... [buildout]
    ... develop = sample
    ... parts = sample-part
    ...
    ... [sample-part]
    ... recipe = sample
    ... eggs = demo<0.3
    ... find-links = %(server)s
    ... index = %(server)sindex
    ... extras = other
    ... """ % dict(server=link_server))

    >>> import os
    >>> os.chdir(sample_buildout)
    >>> buildout = os.path.join(sample_buildout, 'bin', 'buildout')
    >>> print system(buildout),
    Part: sample-part
    Egg requirements:
    demo<0.3
    Working set:
    demo 0.2
    other 1.0
    demoneeded 1.1

We can see that the options were augmented with additionl data
computed by the egg recipe by looking at .installed.cfg:

    >>> cat(sample_buildout, '.installed.cfg')
    [buildout]
    parts = sample-part
    <BLANKLINE>
    [sample-part]
    __buildout_installed__ = 
    __buildout_signature__ = sample-6aWMvV2EJ9Ijq+bR8ugArQ==
    _b = /tmp/tmpb7kP9bsample-buildout/bin
    _d = /tmp/tmpb7kP9bsample-buildout/develop-eggs
    _e = /tmp/tmpb7kP9bsample-buildout/eggs
    eggs = demo<0.3
    executable = /usr/local/bin/python2.3
    extras = other
    find-links = http://localhost:27071/
    index = http://localhost:27071/index
    recipe = sample
